---
title: CSAPP（三）
date: 2026-01-27 16:32 +0800
categories: [CSAPP, ISA]
tags: [assemble, x86, register]
description: 机器级编程
math: true
---

## **基本概念**

**机器语言**：计算机底层芯片真正能理解和执行的语言，由一系列**二进制指令**组成。

**汇编语言**：机器语言的文本表示，只是将每条二进制指令翻译成对应的程序员可读的代码。

> 由于机器语言难读，所以大部分时候机器级编程的实际对象是汇编代码，且可以将其与机器代码的概念互换
{: .prompt-info}

**指令集架构**（$Instruction\ Set\ Architecture,ISA$）：软件和硬件之间接口的完整定义。可以简单地理解为该硬件芯片能运行的汇编语言的语法。

按照指令集的格式可以将其分为两类：

- **复杂指令集计算机**（$Complex\ Instruction\ Set\ Computer，CISC$）：指令集比较丰富，硬件实现相对复杂，汇编编程相对简单；可直接操作内存。

  典型代表：`x86`架构处理器

- **精简指令集计算机**（$Reduced\ Instruction\ Set\ Computer,RISC$）：指令集比较简单，硬件实现相对简单，汇编编程相对复杂；不可直接操作内存。

  典型代表：`MIPS`处理器

**x86**：$Intel$ 开发的`32`位处理器系列，也称作`IA32`，也可指该系列处理器运行的机器语言。名称来源于$Intel$ 第一代芯片`8086`。

> 尽管**x86**通常指代**32**位处理器，但**8086**实际是**16**位微处理器
{: .prompt-tip}

**x64**：又称`x86-64`，是$Intel$ 开发的`64`位处理器系列，也指该系列处理器运行的机器语言。

> 实际上**AMD**生产的处理器也使用**x64**机器语言
{: .prompt-info}

**CSAPP**第三版是针对`x64`机器语言，故笔记也是记录`x64`相关教程。

## **机器代码概述**

### **处理器状态**

相对于`c`语言，机器代码多出了以下概念来表示**处理器状态**：

- **程序计数器**（$Program\ Counter,PC$）：指出将要执行的系一条指令的**内存地址**，在`x86`中用`%rip`表示。
- **整数寄存器**：在`x64`中有`16`个整数寄存器，每个都可存储`64`位值。
- **条件寄存器**：用于存放最近执行的算数或逻辑指令的结果状态，从而实现条件跳转和程序流控制。
- 一组**向量寄存器**可以存放一个或多个整数或浮点数值。

### **代码格式**

**CSAPP**采用`ATT`格式来描述汇编代码，这也是`GCC`、`objdump`等工具描述汇编语言的格式。

`ATT`格式为：`操作 操作数1 操作数2...`

在`Linux`下使用：

```bash
$ gcc target.c -Og -S -o another.s
```

来生成汇编文件，其中`-Og`表示优化的等级，`-S`表示只生成**汇编文件**就结束，`-o`后是目标文件的名称，可省略。若省略则默认为`源文件名称.相应后缀`。

> 这里的**-Og**表示优化等级为调试，生成的汇编代码便于阅读，避免优化过头导致与源文件结构大相径庭
{: .prompt-info}



$Intel$ 和微软采用$Intel$ 格式来描述汇编代码。其与`ATT`格式有如下不同：

- $Intel$ 省略了指示大小的后缀
- $Intel$ 省略了寄存器前面的`%`符号
- $Intel$ 描述内存位置的方式不同，例如是`DWORD PTR [rdi]`而不是`(rdi)`
- 有多个操作数的情况下，$Intel$ 是目的操作数在前，源操作数在后，而`ATT`正好相反。

## **栈帧**

典型的栈帧结构如下：

```
    |               |
    +---------------+ high address（向下生长）
    |               | 保存的寄存器区
    +---------------+
    |               | 局部变量区
    +---------------+
    |               | 调用者传递的参数区
    |               | 调用别的函数时返回的地址
    +---------------+ low address
    |               |
```

在`x86`机器语言中，将一个栈元素的大小看作`8`字节，因为一个地址大小为`8`字节。

每个传入的参数都需要一个栈元素来存储。

而多个局部变量则可以在保证自身地址对齐的情况下存入同一个栈元素中。

`%rsp`指向栈顶元素，更具体地说，指向栈顶元素的头一个字节。

```
+----------------------------+ high address（向下生长）
|  |  |  |  |  |  |  |8(%rsp)|
------------------------------
|  |  |  |  |  |  |  | (%rsp)| 右边是栈元素的头（字节），左边是栈元素的尾（字节）
+----------------------------+ low address
```

#### **保存的寄存器区**

根据惯例，`%rbx`、`%rbp`、和`%r12`~`%r15`称为**被调用者保存寄存器**，意味着被调用者如果要使用该寄存器，需要先将该寄存器的值保存至栈中，如：要使用`%rbx`寄存器，要先执行如下操作：

```assembly
	pushq 	%rbx
```

该操作等价于：

```assembly
	subq	$0x8,%rsp
	movq	%rbx,(%rsp)
```

在返回前还要先从栈中弹出`%rbx`的值：

```assembly
	popq 	%rbx
```

同理，该函数的值等价于：

```assembly
	movq	(%rsp),%rbx
	addq	$0x8,%rsp
```

除了上述寄存器和`%rsp`，其他寄存器都称为**调用者保存寄存器**，意味着被调用者可以随意调用这些寄存器，保存寄存器的值是调用者的责任。
