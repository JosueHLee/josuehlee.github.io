---
title: CSAPP（二）
date: 2026-01-20 17:00 +0800
categories: [CSAPP, Binary]
tags: [the basis of information]     # TAG names should always be lowercase
description: 信息的表示和处理
math: true
---

# **信息存储**

**字节**（$$ byte $$）是计算机寻址的基本单位，$$ 1字节(byte) = 8位(bit) $$。

## **字节顺序**

想象一个写作文的方格纸，当我们写下数字**一千二百三十四**（$$ 1234 $$）时，往往是高位（这里的高位指指数更大）的数字在前，低位（指数更低）的数字在后：

```
 字数1  字数2  字数3  字数4
-------------------------
|  1  |  2  |  3  |  4  |
-------------------------
```

与我们书写习惯一致的字节存储规则在计算机中称为**大端法**（$$ big\space endian $$），例如对于十六进制数：$$ 0x01234567 $$，大端法存储时的字节顺序为（假设起始地址为$$ 0x100 $$）：

```
 0x100  0x101  0x102  0x103
-----------------------------
| 0x01 | 0x23 | 0x45 | 0x67 |
-----------------------------
```

> 正如前文所说：字节是计算机寻址的基本单位，所以一个地址编号对应一个字节。如地址0x100对应其存储的一个字节0x01，里面是8位。
{: .prompt-tip }

由此可见，大端法的最高有效字节在最前面。

> 这里的最高有效字节指的是该字节所表示的二进制数的指数最高，最前面指的是地址的低位

相反地：最低有效**字节**在最前面的存储规则称为**小端法**（$$ little\space endian $$）：

```
 0x100  0x101  0x102  0x103
-----------------------------
| 0x67 | 0x45 | 0x23 | 0x01 |
-----------------------------
```
> 大多数Intel兼容机都只用小端模式，而许多较新的微处理器是双端法——既可以是大端也可以是小端
{: .prompt-info }
> 需要注意的是：存储数据时，计算机也是按字节或字节的整数倍存储的，因此小端法只是逆转了各个字节之间的顺序，而没有逆转每个字节内二进制数据的顺序。<br>
> 比如，对于字节$$ 0x67 $$来说：小端法只是将其从最后一位逆转到第一位存储，而他的内部顺序没有改变，并没有从<br>
$$ 0110(6)\space 0111(7) $$<br>
逆转为<br>
$$ 1110(e)\space 0110(6) $$。
{: .prompt-warning }

# **整数表示**

## **一般情形**

假设一个整数数据有$$ w $$位，将位向量写成 $$ \vec{x} $$，表示整个向量，或者写成$$ [x_{w-1},x_{w-2},···,x_{0}] $$，表示向量中的每一位。

若$$ \vec{x} $$是二进制表示的数，则$$ x_i $$的取值为$$0$$或$$1$$。

设$$ B2U_w(\vec{x}) $$为将无符号的$$ \vec{x} $$转换为十进制数值的函数，则有：<br>


$$
B2U_w(\vec{x})=\sum\limits_{i=0}^{w-1}{x_i2^i}
$$


例如，当$$ \vec{x}=0110$$时：<br>


$$
B2U_4(0110)=x_3\cdot2^3+x_2\cdot2^2+x_1\cdot2^1+x_0\cdot2^0=0+4+2+0=6
$$


## **补码编码**

上述表示法只能表示无符号二进制数，而计算机使用**补码**（$$ Two's complement $$）表示有符号整数。

定义如下：


$$
B2T_w(\vec{x})=-x_{w-1}2^{w-1}+\sum\limits_{i=0}^{w-2}{x_i2^i}
$$


例如，当$$ \vec{x}=0110$$时：


$$
B2UT_4(0110)=-x_3\cdot2^3+x_2\cdot2^2+x_1\cdot2^1+x_0\cdot2^0=-0+4+2+0=6
$$


当$$ \vec{x}=1110$$时：


$$
B2UT_4(1110)=-x_3\cdot2^3+x_2\cdot2^2+x_1\cdot2^1+x_0\cdot2^0=-8+4+2+0=-2
$$


由此可见，补码中计算**二进制表示**的**十进制数值**的方法就是将$$ \vec{x} $$最高位的权重取负值。此时的最高位$$x_{w-1}$$称为符号位，其为$$0$$时表示该数为正数，反之为负数。

> 对于32位整数来说（Java，C中的int类型长度），其符号位就是第31位（从0开始编号）
{: .prompt-info }

使用补码的好处在于可以将减法运算自然地转换为加法运算，例如对于$$ w=4 $$的二进制减法：



$$6_{10}-7_{10}=6_{10}+(-7)_{10}=0110_{2}+1001_{2}=1111_{2}=-1_{10}$$

> 除了补码，还有原码和反码来表示有符号整数，但几乎所有的现代机器都使用补码表示有符号整数。而原码会在浮点数中使用。
{: .prompt-tip}

### **补码的范围**

对于无符号二进制数，其能表示的最大整数$$UMax_w=2^{w}-1$$，即$$ w $$位全取$$1$$的整数。

对于有符号二进制数，其能表示的最大整数$$TMax_w=2^{31}-1$$，即低$$w-1$$位全取$$1$$的整数；而其能表示的最小整数$$TMin_w=-2^{31} $$，即最高位取$$1$$、低$$w-1$$位全取$$0$$的整数。

> 为什么$$TMin_w $$是低位全零？回到$$B2T_w(\vec{x})$$函数，当最高位为$$1$$时：
>
> $$B2T_w(\vec{x})=-1\cdot2^{w-1}+\sum···$$，只有当低$$w-1$$全为$$0$$时，$$ \sum··· $$才能取到最小值$$0$$，此时正是整个补码能表示的最小值
{: .prompt-tip }

以$$32$$位整数为例：

$$
UMax_{32}=0xffffffff=2^{32}-1=4,294,967,295
$$
$$
TMax_{32}=0x7fffffff=2^{31}-1=2,147,483,647
$$
$$
TMin_{32}=0x80000000=-2^{31}=-2,147,483,648
$$

> 这三个数显然难以记忆，但有个简单的估算数量级的方法：
>
> $$2^{10}=1024\approx10^3$$
>
> 因此：
>
> $$2^{32}-1\approx2^{32}=2^2\times2^{10}\times2^{10}\times2^{10}\approx4\times10^3\times10^3\times10^3=4\times10^{9}$$
>
> 同理：
>
> $$2^{31}-1\approx2^{32}=2^1\times2^{10}\times2^{10}\times2^{10}\approx2\times10^3\times10^3\times10^3=2\times10^{9}$$
>
> $$-2^{32}=^1\times2^{10}\times2^{10}\times2^{10}\approx2\times10^3\times10^3\times10^3=2\times10^{9}$$
>{: .prompt-tip}

在$$ w  $$确定的情况下（通常是$$32$$位或$$64$$位），计算机所能表达的数字有限，一旦超出这个范围，就会造成**溢出**（$$overflow$$）

以$$ w=4 $$为例：


$$
6_{10}+4_{10}=0110_2+0100_2=1010_2=-6_{10}
$$


两个整数相加得到一个负数称为**正溢出**，溢出原因是相加的结果太大导致进位进到符号位从而转换为负数。

相应的，负数相加得到一个正数称为**负溢出**：


$$
(-6)_{10}+(-4)_{10}=1010_2+1100_2=0110_2=6_{10}
$$


### **由十进制转补码**

上述内容介绍了二进制补码转十进制数值的$$B2T_w $$方法，若给定一个十进制有符号整数$$x$$，设将其转换为二进制表示的函数为$$f(x)$$，转换后的二进制向量为$$\vec{y}$$，则有：


$$
\vec{y}=\begin{cases}f(x)&x\ge0\\\tilde{f(-x)}+1&x<0\end{cases}
$$


其中$$ \tilde{f(-x)} $$为对该二进制表示按位取反。

# **浮点数表示**

## **一般情形**

与整数的一般情形类似：

一个形如：$b_mb_{m-1}···b_1b_0.b_{-1}b_{-2}···b_{-n-1}b_{-n}$表示的数，$b_i$的取值范围为$0$或$1$，则该表示法表示的数 $B$为：
$$
B=\sum_{i=-n}^{m}2^i\times b_i
$$
该表示法的缺点在于给定位数，难以表示非常大的数（小数部分已经占用了一些位数）

## **IEEE浮点表示**

**IEEE浮点标准**用$V=(-1)^s\times M\times 2^E$来表示一个数，其中：

- $s$作为符号位表示该数为正或负，但数值`0`的符号位解释为特殊情况
- $M$为尾数，是一个二进制小数，一般情况下其取值为$[1,2-\epsilon)$，在$E$为某个特定值时其取值为$[0,1-\epsilon)$

- $E$作为阶码，作用是对浮点数加权，说人话就是指数

**单精度的浮点数表示：**

```
31 30                  23 22                                    0
_________________________________________________________________
|s |        exp         |                 frac                  |
_________________________________________________________________
```

**双精度的浮点数表示：**

```
63 62                          52 51                                                      0
___________________________________________________________________________________________
|s |            exp             |                        frac                             |
___________________________________________________________________________________________
```

## **单精度的浮点数**

单精度的浮点数以`8`位作为阶码，`23`位作为尾数。

根据`exp`的取值不同，可以将浮点数的值分为三种情况：

1. `exp`非全`0`且非全`1`时，称为规格化的
2. `exp`全`0`时，称为非规格化的
3. `exp`全`1`时，浮点数的值根据`frac`的取值为无穷大或`NaN`

### **规格化**

当`exp`非全`0`或全`1`时，阶码$E=e-bias$，$e$是`exp`表示的无符号整数，$bias$的值为$2^{k-1}-1$，$k$为`exp`的位数（单精度为`8`，双精度为`11`）

说人话就是：规格化情况下`exp`表示的无符号数的范围为$[1,254]$，为了使其表示的整数数量级范围和小数数量级范围相近，就将该无符号数减去一个偏置，得到最终的阶码范围为$[-126, 127]$，这样该浮点数的数量级既能小到$2^{-126}$，又能大到$2^{127}$

`frac`的值为$f$，其二进制表示为$0.f_{n-1}f_{n-2}···f_{1}f_{0}$，即该二进制位全为小数部分。同时尾数$M=1+f$，即默认隐含一个`1`，这样做的好处是能增加一个精度

### **非规格化**

当`exp`的值为全`0`时，阶码$E=1-bias$，$bias$的值与上述相同。换言之，上述的$e$无法取到`0`。

此时`frac`的二进制位仍全表示小数部分，但不含隐含的`1`。即$M=f$

**为什么要非规格化？**

假设一个`8`位浮点数，`3`位阶码，`4`位尾数。

则规格化情况下`n-1`值阶码的最大值和`n`值阶码的最小值分别为（假设$exp = 010_2$即$n=-1$）：

$2^{-2}\times (1+\frac{1}{2}+\frac{1}{4}+\frac{1}{8}+\frac{1}{16})=\frac{1}{4}\times \frac{31}{16}=\frac{31}{64},2^{-1}\times 1=\frac{1}{2}=\frac{32}{64}$

采用非规格化，则$exp=000_2$时的最大值和$exp=001_2$时的最小值分别为：

$2^{-2}\times (\frac{1}{2}+\frac{1}{4}+\frac{1}{8}+\frac{1}{16})=\frac{1}{4}\times\frac{15}{16}=\frac{15}{64},2^{-2}\times1=\frac{1}{4}=\frac{16}{64}$

且能表示的最小值为：

$2^{-2}\times \frac{1}{16}=\frac{1}{64}$

若阶码采用规格化的表示，同时又舍弃隐含的`1`（这是为了表示更小数量级的数），此时最小值为：

$2^{-3}\times\frac{1}{16}=\frac{1}{8}\times\frac{1}{16}=\frac{1}{128}$

但最大值为：

$2^{-3}\times(\frac{1}{2}+\frac{1}{4}+\frac{1}{8}+\frac{1}{16})=\frac{1}{8}\times\frac{15}{16}=\frac{15}{128}$

此时与上一阶码的最小值$\frac{1}{4}=\frac{32}{128}$相差了$\frac{17}{128}$，也就是出现了**突变**（相较于非规格化的差值$\frac{1}{64}=\frac{2}{128}$更大）

由此可见，非规格化在保证了从上一阶码的最大值到下一阶码最小值**平滑过渡**的同时，还提供了更小的数量级。

**其他**

当`exp`的值为全`1`时：

- `frac`为全`0`时，该浮点数表示为无穷大，根据符号位解释为正无穷或负无穷
- `frac`非全`0`时，该浮点数表示为`NaN`，非数字

