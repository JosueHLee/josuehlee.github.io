---
title: CSAPP 第二章笔记
date: 2026-01-20 17:00 +0800
categories: [CSAPP, Binary]
tags: [the basis of information]     # TAG names should always be lowercase
description: 关于信息的表示和处理
math: true
---

# **信息存储**

**字节**（$$ byte $$）是计算机寻址的基本单位，$$ 1字节(byte) = 8位(bit) $$。

## **字节顺序**

想象一个写作文的方格纸，当我们写下数字**一千二百三十四**（$$ 1234 $$）时，往往是高位（这里的高位指指数更大）的数字在前，低位（指数更低）的数字在后：

```
 字数1  字数2  字数3  字数4
-------------------------
|  1  |  2  |  3  |  4  |
-------------------------
```

与我们书写习惯一致的字节存储规则在计算机中称为**大端法**（$$ big\space endian $$），例如对于十六进制数：$$ 0x01234567 $$，大端法存储时的字节顺序为（假设起始地址为$$ 0x100 $$）：

```
 0x100  0x101  0x102  0x103
-----------------------------
| 0x01 | 0x23 | 0x45 | 0x67 |
-----------------------------
```

> 正如前文所说：字节是计算机寻址的基本单位，所以一个地址编号对应一个字节。如地址0x100对应其存储的一个字节0x01，里面是8位。
{: .prompt-tip }

由此可见，大端法的最高有效字节在最前面。

> 这里的最高有效字节指的是该字节所表示的二进制数的指数最高，最前面指的是地址的低位

相反地：最低有效**字节**在最前面的存储规则称为**小端法**（$$ little\space endian $$）：

```
 0x100  0x101  0x102  0x103
-----------------------------
| 0x67 | 0x45 | 0x23 | 0x01 |
-----------------------------
```
> 大多数Intel兼容机都只用小端模式，而许多较新的微处理器是双端法——既可以是大端也可以是小端
{: .prompt-info }
> 需要注意的是：存储数据时，计算机也是按字节或字节的整数倍存储的，因此小端法只是逆转了各个字节之间的顺序，而没有逆转每个字节内二进制数据的顺序。<br>
> 比如，对于字节$$ 0x67 $$来说：小端法只是将其从最后一位逆转到第一位存储，而他的内部顺序没有改变，并没有从<br>
$$ 0110(6)\space 0111(7) $$<br>
逆转为<br>
$$ 1110(e)\space 0110(6) $$。
{: .prompt-warning }

# **整数表示**

## **一般情形**

假设一个整数数据有$$ w $$位，将位向量写成 $$ \vec{x} $$，表示整个向量，或者写成$$ [x_{w-1},x_{w-2},···,x_{0}] $$，表示向量中的每一位。

若$$ \vec{x} $$是二进制表示的数，则$$ x_i $$的取值为$$0$$或$$1$$。

设$$ B2U_w(\vec{x}) $$为将无符号的$$ \vec{x} $$转换为十进制数值的函数，则有：<br>


$$
B2U_w(\vec{x})=\sum\limits_{i=0}^{w-1}{x_i2^i}
$$


例如，当$$ \vec{x}=0110$$时：<br>


$$
B2U_4(0110)=x_3\cdot2^3+x_2\cdot2^2+x_1\cdot2^1+x_0\cdot2^0=0+4+2+0=6
$$


## **补码编码**

上述表示法只能表示无符号二进制数，而计算机使用**补码**（$$ Two's complement $$）表示有符号整数。

定义如下：


$$
B2T_w(\vec{x})=-x_{w-1}2^{w-1}+\sum\limits_{i=0}^{w-2}{x_i2^i}
$$


例如，当$$ \vec{x}=0110$$时：


$$
B2UT_4(0110)=-x_3\cdot2^3+x_2\cdot2^2+x_1\cdot2^1+x_0\cdot2^0=-0+4+2+0=6
$$


当$$ \vec{x}=1110$$时：


$$
B2UT_4(1110)=-x_3\cdot2^3+x_2\cdot2^2+x_1\cdot2^1+x_0\cdot2^0=-8+4+2+0=-2
$$


由此可见，补码中计算**二进制表示**的**十进制数值**的方法就是将$$ \vec{x} $$最高位的权重取负值。此时的最高位$$x_{w-1}$$称为符号位，其为$$0$$时表示该数为正数，反之为负数。

> 对于32位整数来说（Java，C中的int类型长度），其符号位就是第31位（从0开始编号）
{: .prompt-info }

使用补码的好处在于可以将减法运算自然地转换为加法运算，例如对于$$ w=4 $$的二进制减法：



$$6_{10}-7_{10}=6_{10}+(-7)_{10}=0110_{2}+1001_{2}=1111_{2}=-1_{10}$$

> 除了补码，还有原码和反码来表示有符号整数，但几乎所有的现代机器都使用补码表示有符号整数。而原码会在浮点数中使用。
{: .prompt-tip}

### **补码的范围**

对于无符号二进制数，其能表示的最大整数$$UMax_w=2^{w}-1$$，即$$ w $$位全取$$1$$的整数。

对于有符号二进制数，其能表示的最大整数$$TMax_w=2^{31}-1$$，即低$$w-1$$位全取$$1$$的整数；而其能表示的最小整数$$TMin_w=-2^{31} $$，即最高位取$$1$$、低$$w-1$$位全取$$0$$的整数。

> 为什么$$TMin_w $$是低位全零？回到$$B2T_w(\vec{x})$$函数，当最高位为$$1$$时：
>
> $$B2T_w(\vec{x})=-1\cdot2^{w-1}+\sum···$$，只有当低$$w-1$$全为$$0$$时，$$ \sum··· $$才能取到最小值$$0$$，此时正是整个补码能表示的最小值
{: .prompt-tip }

以$$32$$位整数为例：

$$
UMax_{32}=0xffffffff=2^{32}-1=4,294,967,295
$$
$$
TMax_{32}=0x7fffffff=2^{31}-1=2,147,483,647
$$
$$
TMin_{32}=0x80000000=-2^{31}=-2,147,483,648
$$

> 这三个数显然难以记忆，但有个简单的估算数量级的方法：
>
> 
>
> $$2^{10}=1024\approx10^3$$
>
> 因此：
>
> $$2^{32}-1\approx2^{32}=2^2\times2^{10}\times2^{10}\times2^{10}\approx4\times10^3\times10^3\times10^3=4\times10^{9}$$
>
> 同理：
>
> $$2^{31}-1\approx2^{32}=2^1\times2^{10}\times2^{10}\times2^{10}\approx2\times10^3\times10^3\times10^3=2\times10^{9}$$
>
> $$-2^{32}=^1\times2^{10}\times2^{10}\times2^{10}\approx2\times10^3\times10^3\times10^3=2\times10^{9}$$
{: .prompt-tip}

在$$ w  $$确定的情况下（通常是$$32$$位或$$64$$位），计算机所能表达的数字有限，一旦超出这个范围，就会造成**溢出**（$$overflow$$）

以$$ w=4 $$为例：


$$
6_{10}+4_{10}=0110_2+0100_2=1010_2=-6_{10}
$$


两个整数相加得到一个负数称为**正溢出**，溢出原因是相加的结果太大导致进位进到符号位从而转换为负数。

相应的，负数相加得到一个正数称为**负溢出**：


$$
(-6)_{10}+(-4)_{10}=1010_2+1100_2=0110_2=6_{10}
$$


### **由十进制转补码**

上述内容介绍了二进制补码转十进制数值的$$B2T_w $$方法，若给定一个十进制有符号整数$$x$$，设将其转换为二进制表示的函数为$$f(x)$$，转换后的二进制向量为$$\vec{y}$$，则有：


$$
\vec{y}=\begin{cases}f(x)&x\ge0\\\tilde{f(-x)}+1&x<0\end{cases}
$$


其中$$ \tilde{f(-x)} $$为对该二进制表示按位取反。