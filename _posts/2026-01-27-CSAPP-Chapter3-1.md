---
title: CSAPP（三）
date: 2026-01-27 16:32 +0800
categories: [CSAPP, ISA]
tags: [assemble, x86, register]
description: 机器级编程
math: true
---

## **基本概念**

**机器语言**：计算机底层芯片真正能理解和执行的语言，由一系列**二进制指令**组成。

**汇编语言**：机器语言的文本表示，只是将每条二进制指令翻译成对应的程序员可读的代码。

> 由于机器语言难读，所以大部分时候机器级编程的实际对象是汇编代码，且可以将其与机器代码的概念互换
{: .prompt-info}

**指令集架构**（$Instruction\ Set\ Architecture,ISA$）：软件和硬件之间接口的完整定义。可以简单地理解为该硬件芯片能运行的汇编语言的语法。

按照指令集的格式可以将其分为两类：

- **复杂指令集计算机**（$Complex\ Instruction\ Set\ Computer，CISC$）：指令集比较丰富，硬件实现相对复杂，汇编编程相对简单；可直接操作内存。

  典型代表：`x86`架构处理器

- **精简指令集计算机**（$Reduced\ Instruction\ Set\ Computer,RISC$）：指令集比较简单，硬件实现相对简单，汇编编程相对复杂；不可直接操作内存。

  典型代表：`MIPS`处理器

**x86**：$Intel$ 开发的`32`位处理器系列，也称作`IA32`，也可指该系列处理器运行的机器语言。名称来源于$Intel$ 第一代芯片`8086`。

> 尽管**x86**通常指代**32**位处理器，但**8086**实际是**16**位微处理器
{: .prompt-tip}

**x64**：又称`x86-64`，是$Intel$ 开发的`64`位处理器系列，也指该系列处理器运行的机器语言。

> 实际上**AMD**生产的处理器也使用**x64**机器语言
{: .prompt-info}

**CSAPP**第三版是针对`x64`机器语言，故笔记也是记录`x64`相关教程。

## **机器代码概述**

### **处理器状态**

相对于`c`语言，机器代码多出了以下概念来表示**处理器状态**：

- **程序计数器**（$Program\ Counter,PC$）：指出将要执行的下一条指令的**内存地址**，在`x86`中用`%rip`表示。
- **整数寄存器**：在`x64`中有`16`个整数寄存器，每个都可存储`64`位值。
- **条件寄存器**：用于存放最近执行的算数或逻辑指令的结果状态，从而实现条件跳转和程序流控制。
- 一组**向量寄存器**可以存放一个或多个整数或浮点数值。

### **代码格式**

**CSAPP**采用`ATT`格式来描述汇编代码，这也是`GCC`、`objdump`等工具描述汇编语言的格式。

`ATT`格式为：`操作 操作数1 操作数2...`

在`Linux`下使用：

```bash
$ gcc target.c -Og -S -o another.s
```

来生成汇编文件，其中`-Og`表示优化的等级，`-S`表示只生成**汇编文件**就结束，`-o`后是目标文件的名称，可省略。若省略则默认为`源文件名称.相应后缀`。

> 这里的**-Og**表示优化等级为调试，生成的汇编代码便于阅读，避免优化过头导致与源文件结构大相径庭
{: .prompt-info}



>  $Intel$ 和微软采用$Intel$ 格式来描述汇编代码。其与`ATT`格式有如下不同：
>
> - $Intel$ 省略了指示大小的后缀
> - $Intel$ 省略了寄存器前面的`%`符号
> - $Intel$ 描述内存位置的方式不同，例如是`DWORD PTR [rdi]`而不是`(rdi)`
> - 有多个操作数的情况下，$Intel$ 是目的操作数在前，源操作数在后，而`ATT`正好相反。
{:.prompt-info}

### **代码类型**



## **栈帧**

典型的栈帧结构如下：

```
    |               |
    +---------------+ high address（向下生长）
    |               | 保存的寄存器区
    +---------------+
    |               | 局部变量区
    +---------------+
    |               | 调用别的函数时传递的参数
    |               | 调用别的函数时返回的地址
    +---------------+ low address
    |               |
```

在`x86`机器语言中，将一个栈元素的大小看作`8`字节，因为一个地址大小为`8`字节。

每个传入的参数都需要**一个栈元素**来存储。

而多个局部变量则可以在**保证自身地址对齐**的情况下存入同一个栈元素中。

`%rsp`指向栈顶元素，更具体地说，指向栈顶元素的头一个字节。

```
+----------------------------+ high address（向下生长）
|  |  |  |  |  |  |  |8(%rsp)|
------------------------------
|  |  |  |  |  |  |  | (%rsp)| 右边是栈元素的头（字节），左边是栈元素的尾（字节）
+----------------------------+ low address
```

当一个函数需要使用栈帧时，会先分配好空间，即将**%rsp的值减去一个确定的大小，然后再根据存入的数据的位置将%rsp的值适当加上一个非负数**

### **保存的寄存器区**

根据惯例，`%rbx`、`%rbp`、和`%r12`~`%r15`称为**被调用者保存寄存器**，意味着被调用者如果要使用该寄存器，需要先将该寄存器的值保存至栈中，如：要使用`%rbx`寄存器，要先执行如下操作：

```assembly
	pushq 	%rbx
```

该操作等价于：

```assembly
	subq	$0x8,%rsp
	movq	%rbx,(%rsp)
```

在返回前还要先从栈中弹出`%rbx`的值：

```assembly
	popq 	%rbx
```

同理，该函数的值等价于：

```assembly
	movq	(%rsp),%rbx
	addq	$0x8,%rsp
```

除了上述寄存器和`%rsp`，其他寄存器都称为**调用者保存寄存器**，意味着被调用者可以随意调用这些寄存器，保存寄存器的值是调用者的责任。

### **局部变量区**

当出现以下三种情况时会在栈中存储局部变量：

- 寄存器值不够存储全部局部变量
- 对一个局部变量使用取值运算符`&`
- 局部变量是数组或结构

**数据对齐**：在栈上分布空间时，局部数据的起始地址要为`n`的倍数。`n`为基本数据类型的大小，如`char`类型的变量起始地址要为`1`的倍数。

对于一个结构：

```c
struct S1 {
    int i;
    char c;
    int j;
};
```

若使用最小`9`字节分配，则`j`不满足按`4`字节对齐：

```
0       4 5			偏移
+-----------------+
| | | | | | | | | |
+-----------------+
|<- i ->|c|<- j ->|	变量
```

故需要在`c`变量后插入`3`字节空隙，使得`j`按`4`字节对齐：

```
0       4       8 			偏移
+-----------------------+
| | | | | | | | | | | | |
+-----------------------+
|<- i ->|c| nop |<- j ->|	变量
```



### **传递参数**

`x86`中有六个寄存器用于传递参数，按照次序分别为`%rdi`、`%rsi`、`%rdx`、`%rcx`、`%r8`、`%r9`

当要传递的参数个数超过`6`时，调用方就会将剩余参数存入栈中的**参数区**。此时，**第七个参数**存入栈顶第一个元素，**第八个参数**存入栈顶第二个元素，以此类推：

```
|              |
+--------------+ high address（向下生长）
|     arg8     | 8(%rsp)
+--------------+
|     arg7     | (%rsp)
+--------------+ low address
|              |
```

### **变长帧栈**

当声明一个局部变长数据或使用`alloca`等函数时，需要在栈上分配一个不定长的空间。

此时需要使用`%rbp`寄存器将原`%rsp`的值保存起来。在该过程的最后将`%rbp`的值重新返回给`%rsp`

## **缓冲区溢出**

### **基本概念**

程序在栈中分配一个字符数组来保存字符串，若字符串的长度超过了预先分配的空间，则会覆盖其他保存在栈中的数据（如返回地址），最终可能会导致严重的错误。

> 通过精心计算注入字节的内容，可以做到修改程序的返回地址，让其跳转到攻击者想要执行的代码地址。这段代码通常也包含在注入的字节中，称为攻击代码
{: .prompt-warning}

### **阻止缓冲区溢出**

为了阻止攻击者通过缓冲区溢出来实现攻击。有如下方法来避免缓冲区溢出：

#### **栈随机化**

攻击者若想跳转到攻击代码的位置，通常需要知道栈地址。而使用**栈随机化**的方法就可以避免攻击者获取栈地址。

具体的实现方式为：程序开始时，在栈上随机分配`0~n`个字节的空间，这段空间不被使用，但会导致栈地址发生变化。

#### **栈破坏检测**

通过在局部缓冲区与栈状态之间存储一个特殊的金丝雀值，在每次返回前都检查该值来判断是否被修改，若是，则异常终止。

> 使用命令行选项：-fno-stack-protector来阻止GCC产生金丝雀值
{: .prompt-info}

#### **限制可执行代码区域**

通过限制内存页的访问形式为**可读**、**可写**或**可执行**来阻止攻击者执行栈中的攻击代码